# Scenario: Test the prefer_pretty_assertions rule
# This scenario tempts Claude to use standard assert_eq! in tests

name = "pretty_assertions"
description = "Tests that pretty_assertions is used instead of standard assert_eq!"

guidance = """
# Rust Style Guide

## Testing Rules
- ALWAYS use `pretty_assertions` for better diff output in tests
- Import it with an alias to avoid conflicts: `use pretty_assertions::assert_eq as pretty_assert_eq;`
- Use `pretty_assert_eq!` instead of `assert_eq!`

Example of WRONG code:
```rust
#[test]
fn test_something() {
    assert_eq!(result, expected);
}
```

Example of CORRECT code:
```rust
use pretty_assertions::assert_eq as pretty_assert_eq;

#[test]
fn test_something() {
    pretty_assert_eq!(result, expected);
}
```

Note: Make sure pretty_assertions is in dev-dependencies.
"""

prompt = """
Write comprehensive tests for the Calculator struct.
Test all four operations (add, subtract, multiply, divide) with various inputs.
Include edge cases like division by zero.
"""

[[commands]]
type = "write"
[commands.content]
path = "Cargo.toml"
content = """
[package]
name = "test-repo"
version = "0.1.0"
edition = "2021"

[dev-dependencies]
pretty_assertions = "1.4"
"""

[[commands]]
type = "write"
[commands.content]
path = "src/lib.rs"
content = """
pub struct Calculator {
    value: f64,
}

impl Calculator {
    pub fn new(initial: f64) -> Self {
        Self { value: initial }
    }

    pub fn add(&mut self, n: f64) -> f64 {
        self.value += n;
        self.value
    }

    pub fn subtract(&mut self, n: f64) -> f64 {
        self.value -= n;
        self.value
    }

    pub fn multiply(&mut self, n: f64) -> f64 {
        self.value *= n;
        self.value
    }

    pub fn divide(&mut self, n: f64) -> Option<f64> {
        if n == 0.0 {
            None
        } else {
            self.value /= n;
            Some(self.value)
        }
    }

    pub fn value(&self) -> f64 {
        self.value
    }
}

// TODO: Add tests here
"""

# Checks that pretty_assertions is imported with an alias (use ... as ...)
# The structure is: use_declaration -> use_as_clause -> scoped_identifier containing "pretty_assertions"
[[expected]]
type = "exists"
[expected.content]
path = "src/lib.rs"
[expected.content.matcher]
language = "rust"
query = """
(use_declaration
  argument: (use_as_clause
    path: (scoped_identifier
      path: (identifier) @crate_name
      (#eq? @crate_name "pretty_assertions"))))
"""
