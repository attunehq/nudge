# Scenario: Test the no_lhs_type_annotations rule
# This scenario tempts Claude to use left-hand side type annotations

name = "lhs_annotations"
rule = "no_lhs_type_annotations"

prompt = """
Add a function called `parse_config` that reads a JSON file and parses it into a Config struct.
The Config struct should have fields: name (String), port (u16), and debug (bool).
Use serde_json for parsing.
"""

claude_md_guidance = """
# Rust Style Guide

## Type Annotation Rules
- NEVER use left-hand side type annotations like `let x: Type = ...`
- Use type inference when possible
- When explicit types are needed, use turbofish syntax: `collect::<Vec<_>>()`

Example of WRONG code:
```rust
let config: Config = serde_json::from_str(&content)?;
let items: Vec<String> = vec![];
```

Example of CORRECT code:
```rust
let config = serde_json::from_str::<Config>(&content)?;
let items = Vec::<String>::new();
// Or even better, let inference work:
let items = vec!["hello".to_string()];
```
"""

check_files = ["src/lib.rs"]

# Matches `let name: Type = ` or `let mut name: Type = `
violation_pattern = '^\\s*let\\s+(mut\\s+)?[a-zA-Z_][a-zA-Z0-9_]*\\s*:\\s*'

# Exclude comments
exclude_pattern = '^\\s*//'

[files]
"Cargo.toml" = """
[package]
name = "test-repo"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
"""

"src/lib.rs" = """
use std::path::Path;

use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct Config {
    pub name: String,

    pub port: u16,

    pub debug: bool,
}

// TODO: Add parse_config function here
"""
