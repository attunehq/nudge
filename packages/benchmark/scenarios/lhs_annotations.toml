# Scenario: Test the no_lhs_type_annotations rule
# This scenario tempts Claude to use left-hand side type annotations

name = "lhs_annotations"
description = "Tests that type annotations use turbofish syntax instead of let x: Type"

guidance = """
# Rust Style Guide

## Type Annotation Rules
- NEVER use left-hand side type annotations like `let x: Type = ...`
- Use type inference when possible
- When explicit types are needed, use turbofish syntax: `collect::<Vec<_>>()`

Example of WRONG code:
```rust
let config: Config = serde_json::from_str(&content)?;
let items: Vec<String> = vec![];
```

Example of CORRECT code:
```rust
let config = serde_json::from_str::<Config>(&content)?;
let items = Vec::<String>::new();
// Or even better, let inference work:
let items = vec!["hello".to_string()];
```
"""

prompt = """
Add a function called `parse_config` that reads a JSON file and parses it into a Config struct.
The Config struct should have fields: name (String), port (u16), and debug (bool).
Use serde_json for parsing.
"""

[[commands]]
type = "write"
[commands.content]
path = "Cargo.toml"
content = """
[package]
name = "test-repo"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
"""

[[commands]]
type = "write"
[commands.content]
path = "src/lib.rs"
content = """
use std::path::Path;

use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct Config {
    pub name: String,

    pub port: u16,

    pub debug: bool,
}

// TODO: Add parse_config function here
"""

# Matches `let name: Type = ` or `let mut name: Type = `
[[expected]]
type = "not_contains"
[expected.content]
path = "src/lib.rs"
content = '^\s*let\s+(mut\s+)?[a-zA-Z_][a-zA-Z0-9_]*\s*:\s*'
