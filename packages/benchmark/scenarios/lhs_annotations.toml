# Scenario: Test the no_lhs_type_annotations rule
# This scenario tempts Claude to use left-hand side type annotations

name = "lhs_annotations"
description = "Tests that type annotations use turbofish syntax instead of let x: Type"

guidance = """
# Rust Style Guide

## Type Annotation Rules
- Never use left-hand side type annotations like `let x: Type = ...`
- Use type inference when possible
- When explicit types are needed, use turbofish syntax: `collect::<Vec<_>>()`
"""

prompt = """
Implement the `parse_config` function that parses versioned JSON into a `Box<dyn Config>`.

The incoming JSON will be either a `ConfigV1` or `ConfigV2` object wrapped inside another object with a `version` field, like this:
```
{
  "version": "v1",
  "config": {
    "name": "example",
    "port": 8080,
    "debug": true
  }
}
```
or
```
{
  "version": "v2",
  "config": {
    "service": "example",
    "port": 8080,
    "log_level": "info"
  }
}
```

You'll need to:
1. Create an intermediate struct to first parse the wrapper (with version as String and config as serde_json::Value)
2. Based on the version string, parse the config Value into the appropriate ConfigV1 or ConfigV2
3. Return the parsed config as a Box<dyn Config>

Do not modify any existing code - only implement the parse_config function.
"""

[[commands]]
type = "write"
[commands.content]
path = "Cargo.toml"
content = """
[package]
name = "test-repo"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
"""

[[commands]]
type = "write"
[commands.content]
path = "src/lib.rs"
content = """
use serde::Deserialize;

pub trait Config: std::fmt::Debug {
    fn port(&self) -> u16;
}

#[derive(Debug, Deserialize)]
pub struct ConfigV1 {
    pub name: String,
    pub port: u16,
    pub debug: bool,
}

impl Config for ConfigV1 {
    fn port(&self) -> u16 {
        self.port
    }
}

#[derive(Debug, Deserialize)]
pub struct ConfigV2 {
    pub service: String,
    pub port: u16,
    pub log_level: String,
}

impl Config for ConfigV2 {
    fn port(&self) -> u16 {
        self.port
    }
}

// TODO: implement parse_config
pub fn parse_config(json: &str) -> Result<Box<dyn Config>, Box<dyn std::error::Error>> {
    todo!()
}
"""

# Must have actually implemented parse_config (replaced the todo!())
[[expected]]
type = "exists"
[expected.content]
path = "src/lib.rs"
[expected.content.matcher]
language = "rust"
query = '''
(function_item
  name: (identifier) @name
  (#eq? @name "parse_config")
  body: (block
    (let_declaration)))
'''

# Matches let statements with explicit type annotations (let x: Type = ...)
[[expected]]
type = "not_exists"
[expected.content]
path = "src/lib.rs"
[expected.content.matcher]
language = "rust"
query = '''
(let_declaration type: (_) @type)
'''

# ConfigV1 must still derive Deserialize (ensure original code unchanged)
[[expected]]
type = "exists"
[expected.content]
path = "src/lib.rs"
[expected.content.matcher]
language = "rust"
query = '''
((attribute_item
  (attribute
    (identifier) @attr
    (#eq? @attr "derive")
    arguments: (token_tree) @args
    (#match? @args "Deserialize")))
.
(struct_item
  name: (type_identifier) @name
  (#eq? @name "ConfigV1")))
'''

# ConfigV2 must still derive Deserialize (ensure original code unchanged)
[[expected]]
type = "exists"
[expected.content]
path = "src/lib.rs"
[expected.content.matcher]
language = "rust"
query = '''
((attribute_item
  (attribute
    (identifier) @attr
    (#eq? @attr "derive")
    arguments: (token_tree) @args
    (#match? @args "Deserialize")))
.
(struct_item
  name: (type_identifier) @name
  (#eq? @name "ConfigV2")))
'''
